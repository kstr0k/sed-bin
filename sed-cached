#!/bin/sh

# Copyright 2021 Alin Mr. <almr.oss@outlook.com>. Licensed under the MIT license (https://opensource.org/licenses/MIT).

# _r4 (return-for) functions save results in _R4_ globals instead of stdout
# avoids forks (pipes + subshells), extra steps when capturing -- $() trims \n

# encode 1st char of $1 if necessary
__char2fchar1_r4() {  # results (_R4_*): encoded-1st-char rest
  _R4_2char2fchar=${1#?}  # rest
  case "$1" in
    [[:alnum:]!@#$^\&\;\ \(\)\`\'+=_,{}.~-]*) _R4_1char2fchar="${1%"$_R4_2char2fchar"}" ;;
    '/'*) _R4_1char2fchar='%2F' ;;
    '\'*) _R4_1char2fchar='%5C' ;;
    ':'*) _R4_1char2fchar='%3A' ;;
    '|'*) _R4_char2fchar='%7C'  ;;
    '<'*) _R4_char2fchar='%3C'  ;;
    '>'*) _R4_char2fchar='%3E'  ;;
    '?'*) _R4_char2fchar='%3F'  ;;
    '*'*) _R4_char2fchar='%2A'  ;;
    '"'*) _R4_1char2fchar='%22' ;;
    '%'*) _R4_1char2fchar='%25' ;;
    '['*) _R4_1char2fchar='['   ;;
    ']'*) _R4_1char2fchar=']'   ;;
       *) _R4_1char2fchar= ;;
  esac
}

# chunk encoders
# encodes chars in $1 to be filename-safe
__chunk_enc_r4() {
  _R4_chunk_enc=
  while [ ${#1} != 0 ]; do
    __char2fchar1_r4 "$1"
    set -- "$_R4_2char2fchar"
    _R4_chunk_enc=$_R4_chunk_enc$_R4_1char2fchar
  done
}
# allow chunk to create subdirs, but prevent non-ASCII and /../ climbing
__chunk_enc_fs_r4() {
  if ! "${SED_CACHE_USE_SAFE_FCHARS:-false}"; then case "$1" in
    *[![:print:]]*|*/../*) ;;  # fall back on slow encoding
    *) _R4_chunk_enc='/C'$1'C/'; return 0 ;;
  esac; fi
  __chunk_enc_r4 "$@"; _R4_chunk_enc='/C'$_R4_chunk_enc'C/'
}

# hash function for pure shell (needs to be fast)
# encodes chunks from script start, then from end
# limits the worst effects of quadratic complexity
__cachename_r4() {  # results (_R4_$function): filename-compatible "hash"
  local i s q0 q1 q2 q3 q4 q5 q6 q7
  q0='?'; q1=$q0$q0; q2=$q1$q1; q3=$q2$q2; q4=$q3$q3; q5=$q4$q4; q6=$q5$q5; q7=$q6$q6

  # fetch 1 16char-chunk @arg's start
  if s=$q4 && [ ${#1} -gt ${#s} ]; then
    # $1=chunk (will be shifted away), $2=rest
    s=${1#$s}; set -- "${1%%"$s"}" "$s"
  # else $1=chunk, remaining=''
  fi
  __chunk_enc_fs_r4 "$1"; if [ $# = 2 ]; then shift; else set -- ''; fi
  _R4_cachename=$_R4_chunk_enc

  # fetch some 16char-chunks @arg's tail
  if s=$q6 && [ ${#1} -gt ${#s} ]; then  # truncate
    s=${1%$s}; set -- "${1##"$s"}"
  fi
  i=4; while [ $i != 0 ] && [ ${#1} != 0 ]; do  # for each chunk
    i=$(( i - 1 ))
    if s=$q4 && [ ${#1} -gt ${#s} ]; then
      s=${1#$s}; set -- "${1%%"$s"}" "$s"
    fi
    __chunk_enc_fs_r4 "$1"; if [ $# = 2 ]; then shift; else set -- ''; fi
    _R4_cachename=$_R4_chunk_enc$_R4_cachename
  done
}

# build new binary, or use cached one if available
__sed_cached_make() {  # args: script
  __cachename_r4 "$1"
  _R4_cachename=$SED_CACHE_DIR/bin/${#1}/c3/$_R4_cachename
  [ -d "$_R4_cachename" ] || mkdir -p "$_R4_cachename"  # TODO: lock etc
  local sfile bfile oldbin="$bin"
  sfile=$_R4_cachename/s1.sed  # TODO; counter
  bfile=$_R4_cachename/s1.bin
  bin=$bfile  # counts on this function NOT being subshell-ed

  if ! [ -r "$sfile" ] || ! [ -r "$bfile" ] || ! { printf '%s' "$1" | cmp >/dev/null 2>&1 "$sfile" -; }; then
    printf '%s' "$1" >"$sfile"  # save script
    __sed_default_make "$1"     # compile
    mv "$oldbin" "$bin"         # save binary
  fi
}

# replace _make hook, invoke `sed` script
__sed_cached_parse_args() {
  : "${SED_CACHE_DIR:=$HOME/.cache/sed-bin}"
  __sed_make() { __sed_cached_make "$@"; }
  __sed_parse_args "$@"
}

__sed_cached_tests() {
for tst in '' '/' '/q' 's/a/b/' 'xy' '/qx' "$@"; do
  __cachename_r4 "$tst"; printf 'c |%s|\n  |%s|\n' "$tst" "$_R4_cachename"
done
}

if [ -z "${SED_DIR:-}" ]; then
  SED_DIR=$0
  case "$SED_DIR" in
    /*) ;;
    *) SED_DIR=$PWD/$0 ;;
  esac
  SED_DIR=${SED_DIR%/*}/
fi
if [ -z "${SED_LIBMODE:-}" ]; then
  set -ue
  SED_LIBMODE=: . "$SED_DIR"/sed
  __sed_cached_parse_args "$@"
fi

## using in library mode from a script: call in subshell any number of times
#SED_LIBMODE=:; SED_DIR=/S/sed-bin; . "$SED_DIR"/sed; . "$SED_DIR"/sed-cached; (__sed_cached_parse_args 's/:/_/g' /etc/passwd)

## benchmark: normal mode
# alias hyfr='hyperfine -M 40'
# alias hyfs='hyperfine -r 2 --show-output'  # check correctness
#seds=/S/sed-bin/sed,/S/sed-bin/sed-cached,'busybox sh /S/sed-bin/sed-cached',sed; bm='for i in $HFCNT; do {sed} "s/:/_/g;s/a/b/g" /etc/passwd; done'; HFCNT="$(seq 1 10)" hyfr -w2 -L sed "$seds" "$bm"

## benchmark: library mode
#export SED_DIR=/S/sed-bin/; seds="$SED_DIR"/sed-cached,'busybox sh "$SED_DIR"/sed-cached','(__sed_cached_main "$@"); :',sed; bm='SED_LIBMODE=:; . "$SED_DIR"/sed; . "$SED_DIR"/sed-cached; set -- "s/:/_/g;s/a/b/g" /etc/passwd; for i in $HFCNT; do {sed} "$@"; done'; HFCNT="$(seq 1 30)" hyfr -w2 -L sed "$seds" "$bm"

## benchmark: truncating
# sh=/bin/sh; q0=\?; q1=$q0$q0; q2=$q1$q1; q3=$q2$q2; q4=$q3$q3; q5=$q4$q4; q6=$q5$q5; q7=$q6$q6; str=$(cat /S/sed-bin/par.sed); export q7 str; hyfr -S $sh -L HH '##,#' -L PP '%%,%' '(set -- "$str"; s0=${1{PP}$q7}; s1=${1##"$s0"}; printf %s\\n "-- {PP} {HH} ${#s0} ${#s1}" "$s1")' '(set -- "$str"; s0=${1{HH}$q7}; s1=${1{PP}"$s0"}; printf %s\\n "-- {PP} {HH} ${#s0} ${#s1}" "$s1")'; echo $sh
